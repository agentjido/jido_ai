# Accuracy Phase 1.3 - Candidate Aggregation - Implementation Summary

**Date**: 2026-01-10
**Feature Branch**: `feature/accuracy-phase-1-3-candidate-aggregation`
**Target Branch**: `feature/accuracy`

## Overview

Implemented Section 1.3 of the accuracy improvement plan: Candidate Aggregation. This phase provides the aggregation strategies needed to select the best answer from multiple candidates generated by the self-consistency process.

## Implementation Details

### Files Created

**Implementation Files**:
- `lib/jido_ai/accuracy/aggregator.ex` (143 lines) - Behavior defining aggregator interface
- `lib/jido_ai/accuracy/aggregators/majority_vote.ex` (359 lines) - Majority vote with answer extraction
- `lib/jido_ai/accuracy/aggregators/best_of_n.ex` (220 lines) - Score-based selection
- `lib/jido_ai/accuracy/aggregators/weighted.ex` (218 lines) - Weighted strategy combination

**Test Files**:
- `test/jido_ai/accuracy/aggregator_test.exs` (28 lines) - Behavior contract tests
- `test/jido_ai/accuracy/aggregators/majority_vote_test.exs` (196 lines) - 21 tests
- `test/jido_ai/accuracy/aggregators/best_of_n_test.exs` (172 lines) - 16 tests
- `test/jido_ai/accuracy/aggregators/weighted_test.exs` (211 lines) - 14 tests

### Test Results

All 54 tests passing:
- Aggregator behavior tests: 3 tests
- MajorityVote tests: 21 tests
- BestOfN tests: 16 tests
- Weighted tests: 14 tests

## Key Technical Decisions

### 1. Default Arguments in Elixir
Elixir doesn't allow default arguments in multiple function clauses. Solution: Declare default in header clause only:
```elixir
def aggregate(candidates, opts \\ [])
def aggregate([], _opts)
def aggregate([single], _opts)
def aggregate(candidates, opts) when is_list(candidates)
```

### 2. MajorityVote Deterministic Tie-Breaking
Map iteration is non-deterministic in Elixir. Solution: Find max votes, get all tied answers, then find first candidate in original order:
```elixir
max_votes = vote_counts |> Map.values() |> Enum.max(fn -> 0 end)
tied_answers = vote_counts |> Enum.filter(fn {_answer, count} -> count == max_votes end)
winner_answer = Enum.find_value(normalized_answers, fn {candidate, normalized_answer} ->
  if normalized_answer in tied_answers, do: normalized_answer
end)
```

### 3. BestOfN Token Efficiency
Treat `nil` token counts as "most efficient" (not least) - candidates without token information win ties over those with high token counts.

### 4. Weighted Strategy Failure Handling
The Weighted aggregator continues execution even if individual strategies fail, marking them as `nil` in results rather than failing entirely.

### 5. Answer Extraction Patterns
10+ patterns tried in sequence:
- Quoted text: `"42"`
- Double newline prefixes: `\n\nAnswer:`, `\n\nTherefore:`, etc.
- Single newline patterns: `\nAnswer:`, `\nTherefore:`, etc.
- Start of content: `^Answer:`, `^Therefore:`, etc.
- Fallback: Last non-empty line

## Aggregator Behavior

The behavior defines two callbacks:

```elixir
@callback aggregate(candidates :: [Candidate.t()], opts :: keyword()) ::
  {:ok, Candidate.t(), metadata()} | {:error, term()}

@callback distribution(candidates :: [Candidate.t()]) ::
  %{String.t() => non_neg_integer()} | nil
```

## Implementation Strategies

### MajorityVote
- Extracts answers from candidates using pattern matching
- Normalizes answers (lowercase, trim, remove punctuation)
- Counts votes and selects most common answer
- Confidence = vote_count / total_candidates
- Tie-breaking: First candidate in original order with winning answer

### BestOfN
- Selects candidate with highest score
- Confidence = the score itself
- Tie-breaking chain:
  1. Fewer tokens wins (nil is most efficient)
  2. Earlier timestamp wins
- Error: `{:error, :no_scores}` if no candidates have scores

### Weighted
- Combines multiple aggregation strategies with weights
- Normalizes weights to sum to 1.0
- Each strategy votes for a candidate (1.0 Ã— weight)
- Winner = candidate with highest combined score
- Default: 50% MajorityVote, 50% BestOfN

## Technical Challenges Overcome

1. **Enum.sum/2 doesn't exist** - Fixed by using `Enum.map(...)` then `Enum.sum/1`
2. **Enum.map_while/2 doesn't exist** - Changed to regular `Enum.map/2`
3. **BestOfN sorting direction** - Sorting descending but taking `List.last()` instead of `List.first()`
4. **Missing else clause in if statements** - Wrapped rest of code in else clause
5. **Charlist in test** - Changed single quotes to double quotes
6. **Test compilation order** - Changed `async: true` to `async: false` for behavior contract tests

## Next Steps

1. Phase 1.4: Integration with Generators (combining Generator and Aggregator)
2. Phase 1.5: Self-Consistency Workflow (end-to-end multi-candidate generation and aggregation)
3. Add aggregator selection strategy configuration
4. Performance benchmarks for large candidate sets (N > 10)

## References

- Planning Document: `notes/features/accuracy-phase-1.3-candidate-aggregation.md`
- Phase Plan: `notes/planning/accuracy/phase-01-self-consistency.md`
