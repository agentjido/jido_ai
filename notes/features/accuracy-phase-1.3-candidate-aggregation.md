# Feature: Accuracy Phase 1.3 - Candidate Aggregation

## Problem Statement

Jido.AI needs candidate aggregation strategies to select the best answer from multiple candidates generated by the self-consistency process. The aggregator must:

1. Support majority voting for self-consistency (select most common answer)
2. Support best-of-N selection (select highest scored candidate)
3. Support weighted combination of multiple strategies
4. Extract final answers from candidate content (handle various formats)
5. Handle ties gracefully with deterministic tie-breaking
6. Provide confidence metrics for selected answers

**Impact**: Without proper aggregation, the multi-candidate generation from Phase 1.2 cannot produce a single best answer, rendering self-consistency ineffective.

## Solution Overview

Create a behavior-based aggregator system with three implementations:

1. **`Jido.AI.Accuracy.Aggregator`** - Behavior defining the aggregator interface
2. **`Jido.AI.Accuracy.Aggregators.MajorityVote`** - Self-consistency through majority voting
3. **`Jido.AI.Accuracy.Aggregators.BestOfN`** - Score-based candidate selection
4. **`Jido.AI.Accuracy.Aggregators.Weighted`** - Weighted combination of strategies

**Key Design Decisions**:
- Use `@behaviour` pattern for extensibility
- Answer extraction handles multiple formats (quotes, "Answer:", "Therefore", last line)
- MajorityVote uses fuzzy matching for similar answers
- BestOfN uses token efficiency as secondary tie-breaker
- Weighted allows combining multiple strategies with normalized weights
- All aggregators return confidence metrics

## Agent Consultations Performed

**Codebase Research**:
- Reviewed `Jido.AI.Accuracy.Generator` behavior pattern
- Reviewed `Jido.AI.Accuracy.Candidate` struct fields
- Reviewed existing aggregation in `Jido.AI.Accuracy.GenerationResult.select_by_strategy/2`
- No external research needed - follows established patterns

## Technical Details

### File Locations

**New Files**:
- `lib/jido_ai/accuracy/aggregator.ex` - Behavior definition
- `lib/jido_ai/accuracy/aggregators/majority_vote.ex` - Majority vote implementation
- `lib/jido_ai/accuracy/aggregators/best_of_n.ex` - Best-of-N implementation
- `lib/jido_ai/accuracy/aggregators/weighted.ex` - Weighted combination
- `test/jido_ai/accuracy/aggregator_test.exs` - Behavior tests
- `test/jido_ai/accuracy/aggregators/majority_vote_test.exs` - MajorityVote tests
- `test/jido_ai/accuracy/aggregators/best_of_n_test.exs` - BestOfN tests
- `test/jido_ai/accuracy/aggregators/weighted_test.exs` - Weighted tests

### Dependencies

- **Existing**: `Jido.AI.Accuracy.Candidate` (from Phase 1.1)
- **Existing**: No external dependencies beyond Elixir standard library

### Aggregator Behavior Definition

```elixir
@callback aggregate(
  candidates :: [Candidate.t()],
  opts :: keyword()
) :: {:ok, Candidate.t(), metadata()} | {:error, term()}

@type metadata :: %{
  confidence: number(),
  vote_distribution: %{String.t() => non_neg_integer()} | nil,
  score_distribution: %{number() => non_neg_integer()} | nil
}
```

### Usage Example

```elixir
# Majority vote for self-consistency
candidates = [
  Candidate.new!(%{content: "The answer is 42"}),
  Candidate.new!(%{content: "The answer is 42"}),
  Candidate.new!(%{content: "The answer is 41"})
]

{:ok, best, metadata} = MajorityVote.aggregate(candidates)
# best.content => "The answer is 42"
# metadata.confidence => 0.67 (2/3 votes)

# Best-of-N selection with pre-assigned scores
candidates = [
  Candidate.new!(%{content: "Answer A", score: 0.8}),
  Candidate.new!(%{content: "Answer B", score: 0.95})
]

{:ok, best, metadata} = BestOfN.aggregate(candidates)
# best.content => "Answer B"
# metadata.confidence => 0.95
```

## Success Criteria

1. `Aggregator` behavior defined with `aggregate/2` callback
2. `MajorityVote` implements behavior correctly
3. `MajorityVote.extract_answer/1` parses various answer formats
4. `MajorityVote` handles ties deterministically
5. `BestOfN` selects highest-scored candidate
6. `BestOfN` uses token efficiency for tie-breaking
7. `Weighted` combines multiple strategies correctly
8. All aggregators return confidence metrics
9. Edge cases handled (empty list, single candidate)
10. All tests pass (minimum 90% coverage)

## Implementation Plan

### Step 1: Create Aggregator Behavior (1.3.1)

- [x] 1.3.1.1 Create `lib/jido_ai/accuracy/aggregator.ex`
- [x] 1.3.1.2 Add comprehensive `@moduledoc`
- [x] 1.3.1.3 Define `@callback aggregate/2`
- [x] 1.3.1.4 Define `@type metadata/0`
- [x] 1.3.1.5 Define `@type aggregate_result/0`
- [x] 1.3.1.6 Document aggregation strategies

### Step 2: Implement MajorityVote Aggregator (1.3.2)

- [x] 1.3.2.1 Create `lib/jido_ai/accuracy/aggregators/majority_vote.ex`
- [x] 1.3.2.2 Add `@moduledoc` explaining majority voting
- [x] 1.3.2.3 Implement `extract_answer/1` with patterns:
  - Final answer in quotes ("42")
  - "Answer:" prefix
  - "Therefore:" prefix
  - "Thus:" prefix
  - "So:" prefix
  - "The answer is:" prefix
  - Last line as fallback
- [x] 1.3.2.4 Implement `normalize_answer/1` for fuzzy matching
- [x] 1.3.2.5 Implement `count_votes/1` for vote tallying
- [x] 1.3.2.6 Implement `aggregate/2` with tie-breaking
- [x] 1.3.2.7 Add confidence calculation (votes / total)
- [x] 1.3.2.8 Implement `vote_distribution/1` for analysis
- [x] 1.3.2.9 Handle edge cases (empty, single candidate)

### Step 3: Implement BestOfN Aggregator (1.3.3)

- [x] 1.3.3.1 Create `lib/jido_ai/accuracy/aggregators/best_of_n.ex`
- [x] 1.3.3.2 Add `@moduledoc` explaining best-of-N
- [x] 1.3.3.3 Implement `aggregate/2` to select max score
- [x] 1.3.3.4 Add confidence based on score (score value itself)
- [x] 1.3.3.5 Handle ties with token efficiency (fewer tokens wins)
- [x] 1.3.3.6 Handle ties with timestamp (earlier wins)
- [x] 1.3.3.7 Return score metadata
- [x] 1.3.3.8 Handle edge cases (empty, single candidate, no scores)

### Step 4: Implement Weighted Aggregator (1.3.4)

- [x] 1.3.4.1 Create `lib/jido_ai/accuracy/aggregators/weighted.ex`
- [x] 1.3.4.2 Add `@moduledoc` explaining weighted combination
- [x] 1.3.4.3 Implement `aggregate/3` with strategy weights
- [x] 1.3.4.4 Support dynamic weight adjustment via opts
- [x] 1.3.4.5 Combine scores from multiple aggregators
- [x] 1.3.4.6 Normalize weights to sum to 1.0
- [x] 1.3.4.7 Select candidate with highest combined score
- [x] 1.3.4.8 Handle edge cases (empty, single candidate)

### Step 5: Create Aggregators Directory

- [x] Create `lib/jido_ai/accuracy/aggregators/` directory
- [x] Create `test/jido_ai/accuracy/aggregators/` directory

### Step 6: Write Unit Tests

**MajorityVote Tests**:
- [x] Test aggregate/2 selects majority answer
- [x] Test aggregate/2 handles ties correctly
- [x] Test aggregate/2 returns vote confidence
- [x] Test extract_answer/1 parses "Answer:" format
- [x] Test extract_answer/1 parses "Therefore:" format
- [x] Test extract_answer/1 parses quoted answers
- [x] Test extract_answer/1 uses last line as fallback
- [x] Test normalize_answer/1 handles whitespace/case
- [x] Test vote_distribution/1 returns correct counts
- [x] Test edge case: empty candidate list
- [x] Test edge case: single candidate
- [x] Test fuzzy matching groups similar answers

**BestOfN Tests**:
- [x] Test aggregate/2 selects highest scored
- [x] Test aggregate/2 handles equal scores
- [x] Test aggregate/2 uses token efficiency for tie-breaking
- [x] Test aggregate/2 uses timestamp for final tie-breaking
- [x] Test aggregate/2 returns score metadata
- [x] Test aggregate/2 returns confidence equal to score
- [x] Test edge case: empty candidate list
- [x] Test edge case: single candidate
- [x] Test edge case: candidates with no scores

**Weighted Tests**:
- [x] Test aggregate/3 combines strategies correctly
- [x] Test aggregate/3 normalizes weights properly
- [x] Test aggregate/3 selects highest combined score
- [x] Test aggregate/3 handles custom weights via opts
- [x] Test edge case: empty candidate list
- [x] Test edge case: single candidate
- [x] Test edge case: single strategy (weight = 1.0)

### Step 7: Verify and Quality Check

- [x] Run `mix test test/jido_ai/accuracy/aggregator*`
- [x] Run `mix test test/jido_ai/accuracy/aggregators/*`
- [x] Verify test coverage > 90%
- [x] Run `mix credo` - no warnings
- [x] Verify documentation completeness

## Current Status

**Status**: âœ… Implementation Complete
**What works**: All aggregators implemented and tested
- Aggregator behavior with `aggregate/2` and `distribution/1` callbacks
- MajorityVote aggregator with answer extraction and fuzzy matching
- BestOfN aggregator with score-based selection and tie-breaking
- Weighted aggregator with strategy combination
- All 54 tests passing
**What's next**: Ready for Phase 1.4 (Integration with Generators)
**How to run tests**: `mix test test/jido_ai/accuracy/aggregator_test.exs test/jido_ai/accuracy/aggregators/`

## Test Results

```
54 tests, 0 failures
- Aggregator behavior tests: 3 tests
- MajorityVote tests: 21 tests
- BestOfN tests: 16 tests
- Weighted tests: 14 tests
```

## Implementation Summary

**Files Created** (Implementation):
- `lib/jido_ai/accuracy/aggregator.ex` (143 lines) - Behavior definition
- `lib/jido_ai/accuracy/aggregators/majority_vote.ex` (359 lines) - Majority vote with answer extraction
- `lib/jido_ai/accuracy/aggregators/best_of_n.ex` (220 lines) - Score-based selection
- `lib/jido_ai/accuracy/aggregators/weighted.ex` (218 lines) - Weighted strategy combination

**Files Created** (Tests):
- `test/jido_ai/accuracy/aggregator_test.exs` (28 lines)
- `test/jido_ai/accuracy/aggregators/majority_vote_test.exs` (196 lines)
- `test/jido_ai/accuracy/aggregators/best_of_n_test.exs` (172 lines)
- `test/jido_ai/accuracy/aggregators/weighted_test.exs` (211 lines)

**Key Technical Decisions**:
1. Default arguments declared in header clause only (Elixir pattern matching constraint)
2. MajorityVote tie-breaking uses original candidate list order for determinism
3. BestOfN treats `nil` token counts as "most efficient" (not least)
4. Weighted aggregator continues if individual strategies fail
5. Answer extraction uses 10+ patterns with fallback to last line

## Notes/Considerations

- **Answer Extraction Patterns**: Multiple patterns tried in sequence to handle various LLM output formats
- **Fuzzy Matching**: Lowercase + trim for comparison; could be enhanced with string similarity in future
- **Tie-Breaking**: Deterministic using score > tokens > timestamp
- **Confidence Metrics**:
  - MajorityVote: vote_count / total_candidates
  - BestOfN: the score itself
  - Weighted: combined weighted score
- **Empty List Handling**: Return `{:error, :no_candidates}` for all aggregators
- **Single Candidate**: Return that candidate with confidence 1.0

## Risks and Mitigations

| Risk | Mitigation |
|------|-----------|
| Answer extraction misses formats | Multiple patterns with fallback to last line |
| Fuzzy matching too aggressive | Keep strict for now; enhance in future phases |
| Ties non-deterministic | Use deterministic tie-break chain (score > tokens > timestamp) |
| Weight normalization issues | Normalize explicitly and validate sum |
| No scores for BestOfN | Return error if all candidates lack scores |
