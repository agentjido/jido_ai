defmodule SparqTest.ParseCase do
  @moduledoc """
  Provides helper functions and assertions for testing parser functionality in Sparq.

  ## Example
      use SparqTest.ParseCase

      test "parses arithmetic expression" do
        assert_parses "add(5, 10)",
          to: {:add, [], [5, 10]},
          evaluates_to: 15
      end
  """
  use ExUnit.CaseTemplate

  alias Sparq.Context

  using do
    quote do
      import SparqTest.ParseCase
      alias Sparq.{Parser, Core}
      # Include AST helpers for comprehensive testing
      use SparqTest.ASTCase
    end
  end

  @doc """
  Asserts that a string parses to the expected AST and optionally verifies evaluation.

  Options:
    * :to - The expected AST structure
    * :evaluates_to - Optional expected evaluation result
    * :with_context - Optional context to use during evaluation
    * :raises - Expected error message if parsing should fail
  """
  def assert_parses(input, opts) when is_binary(input) and is_list(opts) do
    expected_ast = Keyword.get(opts, :to)
    expected_value = Keyword.get(opts, :evaluates_to)
    context = Keyword.get(opts, :with_context, Context.new())
    expected_error = Keyword.get(opts, :raises)

    case Parser.parse(input) do
      {:ok, actual_ast} when is_nil(expected_error) ->
        if expected_ast, do: ExUnit.Assertions.assert(actual_ast == expected_ast)

        if expected_value do
          case Core.execute(actual_ast, context) do
            {:ok, value, _ctx} ->
              ExUnit.Assertions.assert(value == expected_value)

            {:error, error, _ctx} ->
              raise "Evaluation error: #{error.message}"
          end
        end

      {:error, error} when not is_nil(expected_error) ->
        ExUnit.Assertions.assert(error.message =~ expected_error)

      {:error, error} ->
        raise "Parse failed: #{error.message}"

      {:ok, _} when not is_nil(expected_error) ->
        raise "Expected parse error: #{expected_error}, but parsing succeeded"
    end
  end

  @doc """
  Helper for testing partial parsing results.
  Useful when building/testing individual parser combinators.
  """
  def assert_partial_parse(parser, input, expected) do
    case Parser.parse_partial(parser, input) do
      {:ok, result, _rest, _context, _line, _offset} ->
        ExUnit.Assertions.assert(result == expected)

      {:error, reason, _rest, _context, _line, _offset} ->
        raise "Partial parse failed: #{inspect(reason)}"
    end
  end

  @doc """
  Creates parse test cases for a list of input/output pairs.
  Useful for testing multiple simple cases concisely.
  """
  defmacro parse_cases(do: block) do
    quote bind_quoted: [block: block] do
      for {input, expected} <- block do
        test "parses: #{inspect(input)}" do
          assert_parses(input, to: expected)
        end
      end
    end
  end
end
