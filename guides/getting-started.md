Getting Started with Jido HTN

This guide provides a step-by-step introduction to using the Jido HTN (Hierarchical Task Network) module in Elixir. It combines best practices for structuring domains, writing predicates and transformers, and running plans—all while emphasizing type-safety, concurrency, and extensibility. By the end of this guide, you’ll have a fully functioning “HTN domain” you can use in real-world production scenarios.

	Note
This guide assumes you’re comfortable with standard Elixir tooling (Mix, IEx), as well as concurrency and process supervision principles. It also showcases recommended practices such as using @spec and @type, Logger.warning/2, and mocking with Mimic for easier testing.

1. Installation and Project Setup

Add jido_htn to your mix.exs dependencies:

def deps do
  [
    {:jido_htn, "~> 0.1.0"} # adjust to your latest version
  ]
end

Fetch and compile:

mix deps.get
mix compile

You’re now ready to use Jido HTN in your Elixir application.

2. Basic Concepts of Hierarchical Task Networks
	1.	Domain – A container for all your tasks (compound and primitive), allowed workflows (actions/modules), and callbacks.
	2.	Compound Tasks – High-level tasks that decompose into subtasks via methods.
	3.	Primitive Tasks – Low-level tasks that map directly to an action (e.g., logging, moving, calling an external service).
	4.	Predicates – Functions (arity 1) returning a boolean, used to check conditions on the world/state.
	5.	Transformers – Functions (arity 1) returning a new state (map or struct), used to mutate the world/state after an action.
	6.	Plan – A sequence of primitive actions generated by decomposing compound tasks based on current state and method conditions.

3. Creating Your Agent’s State

A typical pattern is to define your agent’s state as an Elixir struct. Doing so helps with clarity, Dialyzer checks, and easy transformations. If your agent is heavily stateful, consider using Ecto Schemas or a custom struct. For example:

defmodule MyAgent do
  @moduledoc """
  Represents the state for our agent. 

  We use a struct with enforced keys for robust pattern matching and 
  easier validation with NimbleOptions or custom checks.
  """

  @enforce_keys [:id, :battery_level, :location]
  defstruct [:id, :battery_level, :location]

  @type location :: :home | :work

  @type t :: %__MODULE__{
          id: String.t(),
          battery_level: non_neg_integer(),
          location: location()
        }

  @doc """
  A convenient constructor for our agent with defaults.
  """
  @spec new(String.t()) :: t()
  def new(id) do
    %__MODULE__{
      id: id,
      battery_level: 100,
      location: :home
    }
  end
end

Here we’ve added a @type t for Dialyzer, ensuring it can catch type mismatches (e.g., if a function tries to pass a float instead of an integer).

	Pro Tip
Run mix dialyzer regularly to spot type issues early. Include @spec and @type to make your intentions explicit.

4. Defining Predicates

Predicates check whether certain conditions hold true in your state. They must:
	•	Have an arity of 1
	•	Return a boolean
	•	Be named descriptively, typically ending with a ?

defmodule MyPredicates do
  @moduledoc """
  Collection of predicate functions for MyAgent states.
  """

  @doc """
  Returns true if the agent's battery is above 30%.
  """
  @spec can_work?(MyAgent.t()) :: boolean
  def can_work?(%MyAgent{battery_level: level}) do
    level > 30
  end

  @doc """
  Checks if the agent is currently at work.
  """
  @spec at_work?(MyAgent.t()) :: boolean
  def at_work?(%MyAgent{location: loc}), do: loc == :work

  @doc """
  Checks if the agent is currently at home.
  """
  @spec at_home?(MyAgent.t()) :: boolean
  def at_home?(%MyAgent{location: loc}), do: loc == :home
end

If you plan to reference these predicates as strings in your HTN domain, you can also store them in your domain callbacks map. Otherwise, you can pass them in as anonymous functions.

5. Defining Transformers

Transformers mutate your state after an action runs. They:
	•	Have an arity of 1
	•	Return a new state (don’t mutate in place, as Elixir is immutable)
	•	Should handle edge cases (e.g., battery not going below 0)

defmodule MyTransformers do
  @moduledoc """
  Transformer functions for MyAgent states.
  """

  @doc """
  Moves the agent to :work and deducts battery cost for traveling.
  """
  @spec move_to_work(MyAgent.t()) :: MyAgent.t()
  def move_to_work(%MyAgent{battery_level: level} = agent) do
    new_level = max(level - 10, 0)
    %{agent | location: :work, battery_level: new_level}
  end

  @doc """
  Decreases the agent's battery by a specified amount.
  """
  @spec decrease_battery(MyAgent.t(), non_neg_integer()) :: MyAgent.t()
  def decrease_battery(%MyAgent{battery_level: level} = agent, cost) do
    new_level = max(level - cost, 0)
    %{agent | battery_level: new_level}
  end
end

6. Building the Domain

The Domain is where you assemble:
	1.	Compound tasks (with methods)
	2.	Primitive tasks (with assigned actions and transformations)
	3.	Allowed workflows (e.g., modules that can be invoked in primitive tasks)

In Jido HTN, you typically use the builder helpers in Jido.HTN.Domain.BuilderHelpers. Let’s create a simple domain where the agent tries to move from home to work and do some work:

defmodule MyAgentDomain do
  @moduledoc """
  This module defines the HTN domain for `MyAgent`.
  """

  alias Jido.HTN.Domain, as: D
  alias MyPredicates, as: P
  alias MyTransformers, as: T
  alias Jido.Actions.Basic, as: B  # B.Log, B.RandomDelay, B.Todo, etc.

  def init_domain do
    "MyAgentDomain"
    |> D.new()
    |> D.compound("root",
      methods: [
        # We'll just have a single subtask in root for demonstration
        %{subtasks: ["go_to_work"]}
      ]
    )
    |> D.compound("go_to_work",
      methods: [
        %{
          conditions: [&P.can_work?/1, &P.at_home?/1],
          subtasks: ["move_to_work_task", "perform_work"]
        },
        # Fallback method
        %{
          conditions: [],
          subtasks: ["do_something_else"]
        }
      ]
    )
    |> D.primitive(
      "move_to_work_task",
      {B.Log, message: "Moving to work!"},
      preconditions: [&P.at_home?/1],
      effects: [&T.move_to_work/1] # changes location to :work
    )
    |> D.primitive(
      "perform_work",
      {B.Todo, todo: "Implement perform_work logic"},
      preconditions: [&P.at_work?/1, &P.can_work?/1],
      effects: [fn agent -> T.decrease_battery(agent, 15) end]  # cost of working
    )
    |> D.primitive(
      "do_something_else",
      {B.Log, message: "No valid conditions, doing something else..."},
      # no preconditions, no effects
      preconditions: [],
      effects: []
    )
    |> D.allow("move_to_work_task", B.Log)
    |> D.allow("perform_work", B.Todo)
    |> D.allow("do_something_else", B.Log)
    |> D.build!()  # returns the built Domain struct or raises on error
  end
end

6.1 Root Task
	•	root is the entry point for the planner. We define it to have a single method that calls ["go_to_work"].
	•	go_to_work is itself a compound task with two possible methods:
	•	Method 1 only applies if (can_work? AND at_home?).
	•	Method 2 is a fallback with no conditions, so it always applies if Method 1 fails.

6.2 Primitive Tasks
	•	"move_to_work_task" calls a B.Log action (just logs) and uses the T.move_to_work/1 transformer as an effect.
	•	"perform_work" calls a B.Todo action and runs a small anonymous function that reduces the battery by 15.
	•	"do_something_else" logs a message, indicating fallback.

6.3 Allowed Workflows
	•	D.allow("move_to_work_task", B.Log) etc. ensures that the module behind B.Log or B.Todo is recognized by the domain as an acceptable workflow. This helps validation.

7. Running Your Planner

With a domain in hand, call Jido.HTN.plan/3 to generate a plan:

defmodule Demo do
  @moduledoc """
  A small module to demonstrate Jido.HTN planning with MyAgent.
  """

  alias Jido.HTN
  alias MyAgent
  alias MyAgentDomain

  @doc """
  Runs a simple plan for our MyAgent.
  
  ## Examples
  
      iex> Demo.run_plan()
      :ok
  
  """
  @spec run_plan() :: :ok
  def run_plan do
    domain = MyAgentDomain.init_domain()
    agent_state = MyAgent.new("agent-1")

    case HTN.plan(domain, agent_state, debug: true) do
      {:ok, plan} ->
        IO.puts("Plan (no debug tree):")
        IO.inspect(plan, label: "plan")

      {:ok, plan, debug_tree} ->
        IO.puts("Plan + debug tree:")
        IO.inspect(plan, label: "plan")
        IO.inspect(debug_tree, label: "debug_tree")

      {:error, reason} ->
        IO.puts("Error: #{inspect(reason)}")
    end

    :ok
  end
end

7.1 Debug Mode
	•	By passing debug: true, you get a 3-tuple: {:ok, plan, debug_tree}.
	•	The plan is a list of {module, keyword_params} tuples representing each primitive task.
	•	The debug_tree is a structured representation of how the planner decided on each method.

	Note
If you want partial decomposition (e.g., only expand up to 3 levels deep), see TaskDecomposer.decompose_task_partial/8. By default, HTN.plan/3 does a full decomposition.

8. Executing the Plan

So far, you’ve only generated a plan. To execute it, you can manually iterate over the plan steps and call your designated “action modules”:

defmodule PlanExecutor do
  @moduledoc """
  Demonstrates a naive approach to executing each step in the plan.
  """

  alias Jido.Actions.Basic
  alias MyAgent

  @doc """
  Executes an HTN plan step-by-step, returning the final state.
  """
  @spec run_plan([{module(), keyword()}], MyAgent.t()) :: MyAgent.t()
  def run_plan([], state), do: state

  def run_plan([{action_module, params} | rest], state) do
    case Basic.run(action_module, params, state) do
      {:ok, new_state} ->
        # Move on to the next step
        run_plan(rest, new_state)

      {:error, reason} ->
        Logger.warning("Plan execution error: #{inspect(reason)}")
        state
    end
  end
end

In the snippet above, Basic.run/3 is an example run function. Adjust it to match how your custom workflows or action modules handle the :run/3 signature.

9. Concurrency and Distribution

Because Elixir’s concurrency model is process-based, you can execute sub-plans in separate processes. For instance, you might:
	•	Start each plan step in a Task if it’s I/O bound
	•	Supervise tasks with a DynamicSupervisor to ensure fault-tolerance
	•	Spread workload across nodes in a cluster using Elixir’s distribution

A simplistic approach might spawn each step in the plan:

defmodule ConcurrentPlanExecutor do
  use GenServer

  @doc false
  def start_link(init_state), do: GenServer.start_link(__MODULE__, init_state, name: __MODULE__)

  @impl true
  def init(state) do
    # Initialize your agent state here
    {:ok, state}
  end

  @doc """
  Public API to run a plan concurrently.
  """
  def run_plan(plan), do: GenServer.cast(__MODULE__, {:run_plan, plan})

  @impl true
  def handle_cast({:run_plan, plan}, state) do
    # Potentially start tasks for each step in the plan
    for step <- plan do
      Task.start(fn ->
        # Perform your action, handle transforms, logs, etc.
        # Update the GenServer state (via handle_call or separate approach)
      end)
    end

    {:noreply, state}
  end
end

	Important
If your plan modifies shared state, you’ll need to carefully handle concurrency to avoid race conditions. Consider an approach where each step returns a partial state, which merges back into a central state. Alternatively, store state in an ETS table or an external DB.

10. Testing and Mocking

10.1 Property-Based Testing

Use StreamData to verify your domain decomposition under random states:

defmodule MyAgentPropertyTest do
  use ExUnit.Case
  use ExUnitProperties

  property "can always plan from random battery levels" do
    check all battery <- StreamData.integer(0..100) do
      agent = %MyAgent{id: "test", battery_level: battery, location: :home}
      domain = MyAgentDomain.init_domain()

      result = Jido.HTN.plan(domain, agent)
      assert match?({:ok, _plan} | {:ok, _plan, _debug}, result) or match?({:error, _}, result)
    end
  end
end

10.2 Mocking with Mimic

Injecting dependencies (like external services or advanced actions) is simpler if you mock them with Mimic:

defmodule MyAgentActionTest do
  use ExUnit.Case
  import Mimic

  setup :set_mimic_global

  test "logs message for move_to_work action" do
    mimic(Jido.Actions.Basic.Log, :run, fn _action, _params, state ->
      {:ok, state}
    end)

    # Now Jido.Actions.Basic.Log.run/3 is mocked for your test
    # ...
  end
end

11. Logging and Observability

Use Logger.warning/2 for important warnings and errors. For more robust telemetry:
	•	Integrate Telemetry events in your domain or tasks
	•	Export metrics with Prometheus.ex or similar

Example:

Logger.warning("Battery level critically low!", agent_id: agent.id, battery: agent.battery_level)

12. Summary of Best Practices
	1.	Type Safety
	•	Annotate all major functions with @spec.
	•	Maintain a top-level @type t for your state struct(s).
	•	Run mix dialyzer to catch mistakes early.
	2.	Documentation and Doctests
	•	Use @moduledoc on each module to explain purpose and usage.
	•	Include @doc examples (and doctests) so new developers can easily try features.
	3.	Structuring Domains
	•	Keep tasks, predicates, and transformers logically separated for clarity.
	•	Leverage D.new(), D.compound(...), D.primitive(...), and D.allow(...) to build up your domain step by step.
	4.	Concurrency & Fault-Tolerance
	•	If decomposition or execution is heavy, run tasks under a Supervisor.
	•	Use multiple nodes if your plan decomposition or execution is CPU-intensive.
	5.	Testing and Mocking
	•	Use ExUnit + StreamData for property-based tests.
	•	Use Mimic to replace external calls.
	•	Keep domain definitions small and composable.
	6.	Logging & Monitoring
	•	Logger.warning/2 for unexpected conditions.
	•	Tag logs with relevant metadata (like agent_id).
	•	Collect Telemetry events for crucial domain steps (like “task decomposition started”, “task completed,” etc.).

Example Putting It All Together

Below is a simplified snippet tying everything in one place:

defmodule MyAgentApp do
  @moduledoc """
  A self-contained example that:
    - Defines a state struct (`MyAgent`)
    - Declares predicates and transformers
    - Builds an HTN domain with `root` -> `go_to_work`
    - Plans and executes the result
  """

  alias Jido.HTN
  require Logger

  # 1) State Definition
  defmodule MyAgent do
    @enforce_keys [:id, :battery_level, :location]
    defstruct [:id, :battery_level, :location]

    @type location :: :home | :work
    @type t :: %__MODULE__{
            id: String.t(),
            battery_level: non_neg_integer(),
            location: location()
          }

    @spec new(String.t()) :: t()
    def new(id), do: %__MODULE__{id: id, battery_level: 100, location: :home}
  end

  # 2) Predicates
  defmodule Predicates do
    @spec can_work?(MyAgent.t()) :: boolean
    def can_work?(%MyAgent{battery_level: level}), do: level > 30

    @spec at_home?(MyAgent.t()) :: boolean
    def at_home?(%MyAgent{location: loc}), do: loc == :home

    @spec at_work?(MyAgent.t()) :: boolean
    def at_work?(%MyAgent{location: loc}), do: loc == :work
  end

  # 3) Transformers
  defmodule Transformers do
    @spec move_to_work(MyAgent.t()) :: MyAgent.t()
    def move_to_work(%MyAgent{battery_level: level} = agent) do
      %{agent | battery_level: max(level - 10, 0), location: :work}
    end

    @spec decrease_battery(MyAgent.t(), non_neg_integer()) :: MyAgent.t()
    def decrease_battery(%MyAgent{battery_level: level} = agent, cost) do
      %{agent | battery_level: max(level - cost, 0)}
    end
  end

  # 4) Domain
  defmodule AgentDomain do
    alias Jido.HTN.Domain, as: D
    alias MyAgentApp.{Predicates, Transformers}
    alias Jido.Actions.Basic, as: B

    def init_domain do
      "MyAgentAppDomain"
      |> D.new()
      |> D.compound("root",
        methods: [%{subtasks: ["go_to_work"]}]
      )
      |> D.compound("go_to_work",
        methods: [
          %{
            conditions: [&Predicates.can_work?/1, &Predicates.at_home?/1],
            subtasks: ["move_to_work_task", "perform_work"]
          },
          # fallback
          %{conditions: [], subtasks: ["do_nothing"]}
        ]
      )
      |> D.primitive(
        "move_to_work_task",
        {B.Log, message: "Moving to work..."},
        preconditions: [&Predicates.at_home?/1],
        effects: [&Transformers.move_to_work/1]
      )
      |> D.primitive(
        "perform_work",
        {B.Todo, todo: "Implement actual work logic here"},
        preconditions: [&Predicates.at_work?/1, &Predicates.can_work?/1],
        effects: [fn agent -> Transformers.decrease_battery(agent, 15) end]
      )
      |> D.primitive(
        "do_nothing",
        {B.Log, message: "Cannot go to work, just idling..."}
      )
      |> D.allow("move_to_work_task", B.Log)
      |> D.allow("perform_work", B.Todo)
      |> D.allow("do_nothing", B.Log)
      |> D.build!()
    end
  end

  # 5) Orchestration
  @doc """
  Orchestrates creating a domain, generating a plan, and printing results.
  """
  @spec demo_run() :: :ok
  def demo_run do
    domain = AgentDomain.init_domain()
    agent_state = MyAgent.new("ag-123")

    Logger.warning("Starting plan decomposition...", agent_id: agent_state.id)

    case HTN.plan(domain, agent_state, debug: true) do
      {:ok, plan, debug_tree} ->
        IO.puts("Plan: #{inspect(plan)}")
        IO.puts("Debug Tree: #{inspect(debug_tree)}")

        # Optionally, you can execute the plan here
        # Or store it for asynchronous processing
        :ok

      {:ok, plan} ->
        IO.inspect(plan, label: "Plan (no debug tree)")
        :ok

      {:error, reason} ->
        Logger.warning("Planning failed: #{inspect(reason)}", agent_id: agent_state.id)
        :ok
    end
  end
end

You now have a fully working HTN example: building a domain, generating a plan, optionally executing that plan, and logging progress.

Next Steps
	•	Add Complex Methods: Introduce additional method decompositions, each with specialized conditions.
	•	Integrate with Phoenix: Accept requests that supply a world state (e.g., battery levels, user input) and respond with a plan.
	•	Leverage Ecto: Persist your agent’s state in a database.
	•	Use GenServers: House your agent’s state in a GenServer or Supervisor for robust concurrency and fault-tolerance.

By following these guidelines—especially around type specs, thorough documentation, concurrency, property-based testing, and mocking—your Jido HTN domains will remain scalable, maintainable, and future-proof for your production Elixir applications. Good luck, and happy planning!