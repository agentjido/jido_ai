defmodule Jido.AI.Accuracy.Candidate do
  @moduledoc """
  Represents a single candidate response in the accuracy improvement system.

  A Candidate contains a generated response along with metadata for scoring,
  comparison, and aggregation. Candidates are generated by various strategies
  (self-consistency, search, reflection) and evaluated using verifiers.

  ## Fields

  - `:id` - Unique identifier for this candidate
  - `:content` - The generated response text
  - `:reasoning` - The reasoning trace (if applicable, for CoT responses)
  - `:score` - The assigned score (from verifier or aggregation)
  - `:tokens_used` - Number of tokens consumed for generation
  - `:model` - The model that generated this candidate
  - `:timestamp` - When this candidate was generated (UTC)
  - `:metadata` - Additional metadata (temperature, etc.)

  ## Usage

      # Create a candidate with minimal fields
      {:ok, candidate} = Candidate.new(%{content: "The answer is 42"})

      # Create a candidate with all fields
      {:ok, candidate} = Candidate.new(%{
        content: "The answer is 42",
        reasoning: "Let me calculate...",
        model: "anthropic:claude-haiku-4-5",
        tokens_used: 125
      })

      # Update score after verification
      updated_candidate = Candidate.update_score(candidate, 0.95)

      # Serialize for storage/transmission
      map = Candidate.to_map(candidate)
      {:ok, restored} = Candidate.from_map(map)
  """

  @type t :: %__MODULE__{
          id: String.t() | nil,
          content: String.t() | nil,
          reasoning: String.t() | nil,
          score: number() | nil,
          tokens_used: non_neg_integer() | nil,
          model: String.t() | nil,
          timestamp: DateTime.t() | nil,
          metadata: map()
        }

  defstruct [
    :id,
    :content,
    :reasoning,
    :score,
    :tokens_used,
    :model,
    :timestamp,
    metadata: %{}
  ]

  @doc """
  Creates a new Candidate from the given attributes.

  ## Parameters

  - `attrs` - Map with candidate attributes:
    - `:content` (optional) - The generated response text
    - `:reasoning` (optional) - Reasoning trace for CoT responses
    - `:score` (optional) - Verification/aggregation score
    - `:tokens_used` (optional) - Token count for generation
    - `:model` (optional) - Model identifier
    - `:id` (optional) - Unique ID, auto-generated if not provided
    - `:timestamp` (optional) - Generation timestamp, defaults to UTC now
    - `:metadata` (optional) - Additional metadata, defaults to `%{}`

  ## Returns

  `{:ok, candidate}` on success.

  ## Examples

      iex> Candidate.new(%{content: "Hello"})
      {:ok, %Candidate{id: id, content: "Hello", ...}}

      iex> Candidate.new(%{content: "Hello", score: 0.9})
      {:ok, %Candidate{content: "Hello", score: 0.9, ...}}
  """
  @spec new(map()) :: {:ok, t()}
  def new(attrs) when is_map(attrs) do
    candidate = %__MODULE__{
      id: Map.get(attrs, :id, generate_id()),
      content: Map.get(attrs, :content),
      reasoning: Map.get(attrs, :reasoning),
      score: Map.get(attrs, :score),
      tokens_used: Map.get(attrs, :tokens_used),
      model: Map.get(attrs, :model),
      timestamp: Map.get(attrs, :timestamp, DateTime.utc_now()),
      metadata: Map.get(attrs, :metadata, %{})
    }

    {:ok, candidate}
  end

  @doc """
  Creates a new Candidate, raising on error.

  Like `new/1` but always returns a candidate. Raises `ArgumentError`
  if attrs is not a map.
  """
  @spec new!(map()) :: t()
  def new!(attrs) when is_map(attrs) do
    case new(attrs) do
      {:ok, candidate} -> candidate
      {:error, reason} -> raise ArgumentError, "Invalid candidate: #{format_error(reason)}"
    end
  end

  def new!(attrs) do
    raise ArgumentError, "Invalid candidate: expected a map, got #{inspect(attrs)}"
  end

  @doc """
  Updates the score of a candidate.

  ## Parameters

  - `candidate` - The candidate to update
  - `score` - The new score (numeric value)

  ## Returns

  An updated candidate struct with the new score.

  ## Examples

      iex> candidate = Candidate.new!(%{content: "Answer"})
      iex> Candidate.update_score(candidate, 0.95)
      %Candidate{content: "Answer", score: 0.95, ...}
  """
  @spec update_score(t(), number()) :: t()
  def update_score(%__MODULE__{} = candidate, score) when is_number(score) do
    %{candidate | score: score}
  end

  @doc """
  Serializes a candidate to a map.

  Converts the candidate struct to a plain map suitable for
  JSON encoding or storage. The timestamp is converted to an ISO8601 string.

  ## Parameters

  - `candidate` - The candidate to serialize

  ## Returns

  A map with string keys for JSON compatibility.

  ## Examples

      iex> candidate = Candidate.new!(%{content: "Hello"})
      iex> map = Candidate.to_map(candidate)
      iex> is_map(map) and map["content"] == "Hello"
      true
  """
  @spec to_map(t()) :: map()
  def to_map(%__MODULE__{} = candidate) do
    %{
      "id" => candidate.id,
      "content" => candidate.content,
      "reasoning" => candidate.reasoning,
      "score" => candidate.score,
      "tokens_used" => candidate.tokens_used,
      "model" => candidate.model,
      "timestamp" => format_timestamp(candidate.timestamp),
      "metadata" => candidate.metadata
    }
  end

  @doc """
  Deserializes a map to a candidate.

  Reconstructs a candidate from a map created by `to_map/1`.
  Handles string keys for JSON compatibility.

  ## Parameters

  - `map` - A map with candidate data

  ## Returns

  `{:ok, candidate}` on success, `{:error, reason}` on failure.

  ## Examples

      iex> map = %{"content" => "Hello", "id" => "test_123"}
      iex> {:ok, candidate} = Candidate.from_map(map)
      iex> candidate.content
      "Hello"
  """
  @spec from_map(map()) :: {:ok, t()} | {:error, term()}
  def from_map(map) when is_map(map) do
    try do
      attrs = extract_attrs_from_map(map)
      new(attrs)
    rescue
      _e in [ArgumentError, KeyError, MatchError] ->
        {:error, :invalid_map}
    end
  end

  def from_map(_invalid) do
    {:error, :invalid_map}
  end

  @doc """
  Deserializes a map to a candidate, raising on error.

  Like `from_map/1` but always returns a candidate. Raises `ArgumentError`
  if the map is invalid.
  """
  @spec from_map!(map()) :: t()
  def from_map!(map) when is_map(map) do
    case from_map(map) do
      {:ok, candidate} -> candidate
      {:error, reason} -> raise ArgumentError, "Invalid candidate map: #{format_error(reason)}"
    end
  end

  def from_map!(invalid) do
    raise ArgumentError, "Invalid candidate map: expected a map, got #{inspect(invalid)}"
  end

  # Private functions

  defp generate_id do
    "candidate_#{Jido.Util.generate_id()}"
  end

  defp extract_attrs_from_map(map) do
    %{
      id: Map.get(map, "id") || Map.get(map, :id),
      content: Map.get(map, "content") || Map.get(map, :content),
      reasoning: Map.get(map, "reasoning") || Map.get(map, :reasoning),
      score: Map.get(map, "score") || Map.get(map, :score),
      tokens_used: Map.get(map, "tokens_used") || Map.get(map, :tokens_used),
      model: Map.get(map, "model") || Map.get(map, :model),
      timestamp: parse_timestamp(Map.get(map, "timestamp") || Map.get(map, :timestamp)),
      metadata: Map.get(map, "metadata") || Map.get(map, :metadata) || %{}
    }
  end

  defp format_timestamp(nil), do: nil
  defp format_timestamp(%DateTime{} = dt), do: DateTime.to_iso8601(dt)
  defp format_timestamp(str) when is_binary(str), do: str
  defp format_timestamp(_), do: nil

  defp parse_timestamp(nil), do: nil
  defp parse_timestamp(""), do: nil

  defp parse_timestamp(str) when is_binary(str) do
    case DateTime.from_iso8601(str) do
      {:ok, dt, _} -> dt
      _ -> nil
    end
  end

  defp parse_timestamp(%DateTime{} = dt), do: dt
  defp parse_timestamp(_), do: nil
  defp format_error(atom) when is_atom(atom), do: atom
  defp format_error(_), do: :invalid_attributes
end
