defmodule Mix.Tasks.Jido.Ai.Playground do
  @shortdoc "Launch Phoenix Playground chat interface for Jido AI"
  @moduledoc """
  Launches a Phoenix Playground web interface for chatting with AI models using Jido AI.

  ## Usage

      mix jido.ai.playground
      mix jido.ai.playground --model openrouter:anthropic/claude-3.5-sonnet
      mix jido.ai.playground --port 4000

  ## Options

    * `--model` - Model to use (default: "openrouter:openai/gpt-oss-20b:free")
    * `--port` - Port to run the server on (default: 4001)

  """

  use Mix.Task

  @impl Mix.Task
  def run(args) do
    Application.ensure_all_started(:jido_ai)

    {opts, _args_list, _} =
      OptionParser.parse(args,
        switches: [
          model: :string,
          port: :integer
        ]
      )

    default_model = Application.get_env(:jido_ai, :default_model, "openrouter:openai/gpt-oss-20b:free")
    model = Keyword.get(opts, :model, default_model)
    port = Keyword.get(opts, :port, 4001)

    IO.puts("ðŸš€ Starting Jido AI Playground...")
    IO.puts("Model: #{model}")
    IO.puts("Port: #{port}")
    IO.puts("")
    IO.puts("Open your browser to http://localhost:#{port}")
    IO.puts("Press Ctrl+C to stop")
    IO.puts("")

    # Create the playground file content
    playground_content = playground_live_content(model, port)

    # Write to temporary file
    playground_file = Path.join(System.tmp_dir!(), "jido_ai_playground.exs")
    File.write!(playground_file, playground_content)

    # Start the playground using the temporary file
    Code.compile_file(playground_file)

    # Keep the process alive
    Process.sleep(:infinity)
  end

  defp playground_live_content(model, port) do
    """
    # Jido AI Playground - Generated by mix jido.ai.playground

    defmodule JidoAIPlaygroundLive do
      use Phoenix.LiveView
      
      @model "#{model}"

      def mount(_params, _session, socket) do
        {:ok, assign(socket, messages: [], input: "", loading: false, model: @model, current_assistant_id: nil)}
      end

      def render(assigns) do
        ~H\"\"\"
        <div class="playground-container">
          <h1>ðŸ¤– Jido AI Playground</h1>
          <p>Model: <code>{@model}</code></p>
          
          <div class="chat-container" id="chat">
            <div :for={message <- @messages} class={"message message-" <> message.role} id={"msg-" <> message.id}>
              <div class="content">
                <%= if message.role == "assistant" do %>
                  <%= Phoenix.HTML.raw(format_markdown(message.content)) %>
                <% else %>
                  {message.content}
                <% end %>
              </div>
            </div>
          </div>
          
          <form phx-submit="send_message" class="input-form">
            <div class="input-container">
              <input 
                type="text" 
                name="message" 
                value={@input}
                phx-change="input_change"
                placeholder="Type your message here..."
                disabled={@loading}
                autofocus
              />
              <button type="submit" disabled={@loading || @input == ""}>
                <%= if @loading, do: "Thinking...", else: "Send" %>
              </button>
            </div>
          </form>
        </div>

        <style type="text/css">
          body { font-family: system-ui, sans-serif; margin: 0; padding: 0; background: #f5f5f5; height: 100vh; }
          .playground-container { width: 100%; height: 100vh; background: white; padding: 20px; box-sizing: border-box; display: flex; flex-direction: column; }
          h1 { color: #333; margin-bottom: 10px; }
          p { color: #666; margin-bottom: 20px; }
          code { background: #f1f1f1; padding: 2px 6px; border-radius: 3px; font-family: 'SF Mono', Monaco, monospace; }
          .chat-container { border: 1px solid #ddd; border-radius: 8px; flex: 1; overflow-y: auto; padding: 15px; margin-bottom: 20px; background: #fafafa; }
          .message { margin-bottom: 15px; }
          .message-user { text-align: right; }
          .message-assistant { text-align: left; }
          .message-user .content { background: #007bff; color: white; padding: 10px 15px; border-radius: 18px; display: inline-block; max-width: 70%; word-wrap: break-word; }
          .message-assistant .content { background: #e9ecef; color: #333; padding: 10px 15px; border-radius: 18px; display: inline-block; max-width: 70%; word-wrap: break-word; white-space: pre-wrap; }
          .input-form { }
          .input-container { display: flex; gap: 10px; }
          input[type="text"] { flex: 1; padding: 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 16px; }
          input[type="text"]:focus { outline: none; border-color: #007bff; box-shadow: 0 0 0 2px rgba(0,123,255,0.25); }
          button { padding: 12px 24px; background: #007bff; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: 500; }
          button:hover:not(:disabled) { background: #0056b3; }
          button:disabled { background: #6c757d; cursor: not-allowed; }
          .loading { opacity: 0.7; }
        </style>


        \"\"\"
      end

      def handle_event("input_change", %{"message" => message}, socket) do
        {:noreply, assign(socket, input: message)}
      end

      def handle_event("send_message", %{"message" => message}, socket) when message != "" do
        user_message = %{
          id: :crypto.strong_rand_bytes(8) |> Base.encode64(),
          role: "user",
          content: message
        }
        
        # Create assistant message placeholder
        assistant_id = :crypto.strong_rand_bytes(8) |> Base.encode64()
        assistant_message = %{
          id: assistant_id,
          role: "assistant",
          content: ""
        }
        
        updated_socket = socket
        |> assign(loading: true, input: "")
        |> assign(messages: socket.assigns.messages ++ [user_message, assistant_message])
        |> assign(current_assistant_id: assistant_id)

        # Start async task for AI response streaming
        live_view_pid = self()
        spawn(fn -> 
          IO.puts("Task started for message: " <> message)
          stream_ai_response(live_view_pid, message, assistant_id)
        end)
        
        {:noreply, updated_socket}
      end

      def handle_event("send_message", _params, socket) do
        {:noreply, socket}
      end

      def handle_info({:stream_chunk, assistant_id, chunk}, socket) do
        IO.puts("Received chunk in LiveView: " <> inspect(chunk) <> " for assistant: " <> assistant_id)
        updated_messages = Enum.map(socket.assigns.messages, fn msg ->
          if msg.id == assistant_id do
            new_content = msg.content <> chunk
            IO.puts("Updating message content to: " <> inspect(new_content))
            %{msg | content: new_content}
          else
            msg
          end
        end)
        
        IO.puts("Updated messages: " <> inspect(updated_messages))
        {:noreply, assign(socket, messages: updated_messages)}
      end

      def handle_info({:stream_complete, _assistant_id}, socket) do
        {:noreply, assign(socket, loading: false)}
      end

      def handle_info({:stream_error, assistant_id, error}, socket) do
        updated_messages = Enum.map(socket.assigns.messages, fn msg ->
          if msg.id == assistant_id do
            %{msg | content: "Error: " <> inspect(error)}
          else
            msg
          end
        end)
        
        {:noreply, assign(socket, messages: updated_messages, loading: false)}
      end

      defp stream_ai_response(pid, message, assistant_id) do
        IO.puts("Starting stream for message: " <> message)
        case Jido.AI.stream_text(@model, message) do
          {:ok, stream} ->
            IO.puts("Got stream, starting enumeration...")
            try do
              Enum.each(stream, fn chunk ->
                if chunk != "" do
                  IO.puts("Sending chunk: " <> inspect(chunk))
                  send(pid, {:stream_chunk, assistant_id, chunk})
                end
              end)
              IO.puts("Stream complete")
              send(pid, {:stream_complete, assistant_id})
            rescue
              error ->
                IO.puts("Stream error: " <> inspect(error))
                send(pid, {:stream_error, assistant_id, error})
            end
          {:error, error} ->
            IO.puts("LLM Error: " <> inspect(error))
            send(pid, {:stream_error, assistant_id, error})
        end
      end

      defp format_markdown(content) do
        case Earmark.as_html(content) do
          {:ok, html, []} -> html
          {:ok, html, _warnings} -> html
          {:error, _html, _errors} -> content
        end
      end
    end

    PhoenixPlayground.start(live: JidoAIPlaygroundLive, port: #{port})
    """
  end
end
